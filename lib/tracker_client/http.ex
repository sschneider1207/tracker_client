defmodule TrackerClient.HTTP do
  @moduledoc """
  Makes announcements to trackers following the HTTP tracking protocol.
  """

  @behaviour TrackerClient
  @params ~w(info_hash peer_id port uploaded downloaded left compact no_peer_id event ip numwant key trackerid)a
  @useragent ~c(:httpc/19.2)

  alias TrackerClient.{Announcement, Peer}

  @doc """
  See `TrackerClient`

  # Params

   * `info_hash` - urlencoded 20-byte SHA1 hash of the value of the info key from the Metainfo file.
   * `peer_id` - urlencoded 20-byte string used as a unique ID for the client, generated by the client at startup.
   * `port` - the port number that the client is listening on.
   * `uploaded` - total amount of bytes uploaded.
   * `downloaded` - total amount of bytes downloaded.
   * `left` - how many bytes are left.
   * `compact` - setting this to 1 indicates that the client accepts a compact response.
   * `no_peer_id` - indicates that the tracker can omit peer id field in peers dictionary.
   * `event` - `:started`, `:stopped`, `:completed`, or not included.
   * `ip` - true ip of the client.
   * `numwant` - how many peers the client wants.
   * `key` - additional identification for the client.
   * `trackerid` - if a previous announce contained a tracker id, include it here.
  """
  def announce(announce, params) do
    query =
      params
      |> Keyword.take(@params)
      |> URI.encode_query()
    url = String.to_char_list("#{announce}?#{query}")
    with {:ok, {_status, _, body}} <- :httpc.request(:get, {url, [{'user-agent', @useragent}]}, [], []),
         {:ok, response} <- Benx.decode(body)
    do
      case response do
        %{"failure reason" => reason} -> {:error, reason}
        %{"warning message" => reason} -> {:error, reason}
        response -> {:ok, parse_response(response)}
      end
    else
      _ -> {:error, "http error"}
    end
  end

  defp parse_response(response) do
    interval = response["interval"]
    trackerid = response["tracker id"]
    seeders = response["complete"] || 0
    leechers = response["incomplete"] || 0
    peers = parse_peers(response["peers"])
    Announcement.new(interval, seeders, leechers, peers, trackerid)
  end

  defp parse_peers(peers) when is_list(peers) do
    Enum.map(peers, fn peer ->
      peer_id = peer["peer id"]
      ip = peer["ip"]
      port = peer["port"]
      Peer.new(peer_id, ip, port)
    end)
  end
  defp parse_peers(peers) when is_binary(peers) do
    Peer.parse_binary_peers(peers)
  end
end
